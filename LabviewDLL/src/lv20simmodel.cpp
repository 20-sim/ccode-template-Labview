/**********************************************************
 * This file is generated by the 20-sim C++ Code Generator
 *
 *  file:  %FILE_NAME%
 *  subm:  %SUBMODEL_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************
 * See Labview "Call Library Function Node" help for an
 * explanation on the mapping of C/C++ functions exported
 * by a DLL to a code-VI block in Labview
 **********************************************************/

#include <stdio.h>
#include <stdarg.h>
#include "common/trace.h"

#include "lv20simmodel.h"
#include "%SUBMODEL_NAME%.h"

%SUBMODEL_NAME% my20simSubmodel;
double localTime = 0.0; /* For testing purposes inside 20-sim */

/* DLL Error message */
const int cLastErrorMessageSize = 1024;
char _lasterrormessage[cLastErrorMessageSize];	/* Used to store a DLL error message for transfer to Labview */

extern "C"
{
	int count;
	bool initialized = false;
	
	/* See for supported data types:
	 * http://zone.ni.com/devzone/cda/tut/p/id/3188
	 */
	 
	/**
	 * Settings array elements
	 * [0] = starttime
	 * [1] = finishtime
	 * [2] = stepsize
	 *.[3] = inputs
	 * [4] = outputs
	 */
	DLLEXPORT int GetSettings(double* starttime, double* finishtime, double* stepsize, int* inputs, int* outputs)
	{	TRACE("GetSettings");
		
		DPRINTF("%SUBMODEL_NAME% generated at %GENERATION_DATE% %GENERATION_TIME%");

		if (*finishtime != 0.0)
		{
			my20simSubmodel.SetFinishTime(*finishtime);
		}
		else
		{
			my20simSubmodel.SetFinishTime(%FINISH_TIME%);
			*finishtime = %FINISH_TIME%;
		}
		
		*starttime = %START_TIME%;
		*stepsize = %TIME_STEP_SIZE%;
		*inputs = %NUMBER_INPUTS%;
		*outputs = %NUMBER_OUTPUTS%;
		initialized = false;
		
		return FUNCTION_OK;
	}
	
	DLLEXPORT int Initialize(void)
	{	TRACE("Initialize");

		/* initialize the submodel itself */
		my20simSubmodel.Reset(0.0);
		count = 0;
		initialized = true;

		/* Reset any previous error messages */
		SetErrorMessage("");

		return FUNCTION_OK;    /* Success */
	}

	DLLEXPORT int Terminate(double* inarr, int inputs, double* outarr, int outputs, double* time)
	{	TRACE("Terminate");
		/* perform the final calculations */
		my20simSubmodel.Terminate (inarr, outarr);
		return FUNCTION_OK;    /* Success */
	}

	DLLEXPORT int CalculateStep(double* inarr, int inputs, double* outarr, int outputs, double* time)
	{	TRACE("CalculateStep");
		
		if ((false == initialized) || (*time < my20simSubmodel.GetTime() ))
		{
			DPRINTF("inputs: %d outputs: %d count: %d", inputs, outputs, count);
			
			/* Check inarr and outarr sizes against expected values */
			if (inputs < %NUMBER_INPUTS%)
			{
				DPRINTF("input array size mismatch: 20-sim: %NUMBER_INPUTS%, labview: %d ", inputs);
				return INPUT_COUNT_MISMATCH;
			}
			if (outputs != %NUMBER_OUTPUTS%)
			{
				DPRINTF("output array size mismatch: 20-sim: %NUMBER_OUTPUTS%, labview: %d ", outputs);
				return OUTPUT_COUNT_MISMATCH;
			}
			
			/* Initialize model */
			Initialize();
		}
		/* Multiply the input value with -1 and return */
		my20simSubmodel.Calculate (inarr, outarr);
		*time = my20simSubmodel.GetTime();
		count++;

		if (my20simSubmodel.IsFinished())
		{
			DPRINTF("Finished at time: %f step count %d", *time);
			return MODEL_FINISHED;
		}
		else
		{
			DPRINTF("Time: %f step count %d", *time, count);
			return FUNCTION_OK;    /* Success */
		}
	}

	/* For testing purposes inside 20-sim */
	DLLEXPORT int TestLabviewDLL(double *inarr, int inputs, double *outarr, int outputs, int major)
	{	//TRACE("TestLabviewDLL");
		if (major)
		{
			if (CalculateStep(inarr, inputs, outarr, outputs, &localTime) == MODEL_FINISHED)
			{
				return FUNCTION_FAILED;
			}
		}
		return FUNCTION_OK;
	}

	DLLEXPORT char* LastErrorMessage()
	{
		return _lasterrormessage;
	}
} // extern "C"

/****** Internal support functions ************************************************************/
void SetErrorMessage(const char *format, ...)
{
	va_list args;    
	va_start(args, format);

	vsnprintf_s(_lasterrormessage, cLastErrorMessageSize, cLastErrorMessageSize, format, args);

	va_end(args);

	DPRINTF("Error: %s\n", _lasterrormessage);
}